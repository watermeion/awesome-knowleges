# 服务定位
## 主机 + 端口
传统的服务，都是基于TCP/IP协议，服务唯一的表示，就是主机+端口，服务部署多个实例的时候，通过客户端配置多个地址，做负载均衡来完成。
## 域名 + DNS
 相对于客户端的负载均衡，域名是类似于服务端的负载均衡。域名是从互联网诞生，http领域，用来定位服务的另一种形式，相比主机+端口，明显域名更加便于记忆，做互联网的推广。 为了解决域名Server的不灵活，负载均衡（F5，Nginx)等也应用而生。
## Name + 注册中心
  当前主流的微服务调用模式。使用name来唯一代替服务。不再依赖于域名，ip等资源。具有更灵活的控制。
  
  Name 可以是类名+方法名，可以使自定义的其他方式。
  
  所有的服务RPC，HTTP都以别名来代表，类似于DNS，使用注册中心来代替DNS Server， 负载均衡仍然是由客户端来完成。
## 端口转发（主机+端口的改进）
  使用本地的端口来代替远程的服务，本地提供的服务也用一个端口来代替。相对于各种负载均衡，注册中心等方式，把每个服务对应一个端口，然后使用Iptables 做端口转发到真正的服务，这种本质上是加了个代理，远程的服务，依赖于具体的IPtables规则。如果依赖服务变化，直接修改端口转发规则即可
  
  问题的Iptable 的转发，无法转发到多台机器。但是可以修改为每个服务依赖于多个端口。不过显然，不是那么灵活。
## Proxy 模式
类似于端口转发， 提供的服务以及依赖的服务，都是通过Proxy来完成。不再依赖于端口，而改为Name方式， 具体工作由单独的Proxy 软件来完成 ，这样，服务依赖的变化等，都有Proxy来完成。现在的Service Mesh 就类似于这种。 此外Proxy还可以服务发现，负载均衡，故障屏蔽，Tracing等策略。

# 服务协议
 二进制和字符类协议，或者说是机器可读与人类可读
